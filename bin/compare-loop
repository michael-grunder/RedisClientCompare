#!/usr/bin/env php
<?php

declare(strict_types=1);

use Michaelgrunder\RedisClientCompare\Command\Command;
use Michaelgrunder\RedisClientCompare\Logger\ExceptionFormatter;
use Michaelgrunder\RedisClientCompare\Logger\LoggerFactory;
use Psr\Log\LoggerInterface;

require __DIR__ . '/../vendor/autoload.php';

ini_set('display_errors', 'stderr');

$opt = getopt('', [
    'old:',
    'new:',
    'iters:',
    'sleep:',
    'count:',
    'host:',
    'port:',
    'loglevel:',
    'keys:',
    'members:',
    'cluster',
]);

if (!isset($opt['old'], $opt['new'])) {
    usage();
    exit(2);
}

$phpOld = $opt['old'];
$phpNew = $opt['new'];
$iterations = (int) ($opt['iters'] ?? 0);
$sleepSeconds = (int) ($opt['sleep'] ?? 0);
$commandCount = (int) ($opt['count'] ?? 200);
$host = $opt['host'] ?? '127.0.0.1';
$port = (int) ($opt['port'] ?? 6379);
$logLevel = normalizeLogLevel((string) ($opt['loglevel'] ?? 'info'));
$keys = (int) ($opt['keys'] ?? Command::DEFAULT_KEY_CARDINALITY);
$members = (int) ($opt['members'] ?? Command::DEFAULT_MEMBER_CARDINALITY);
$clusterMode = array_key_exists('cluster', $opt);

if ($keys < 1) {
    fwrite(STDERR, "--keys must be >= 1\n");
    exit(2);
}

if ($members < 1) {
    fwrite(STDERR, "--members must be >= 1\n");
    exit(2);
}

try {
    $logger = LoggerFactory::create($logLevel);
} catch (Throwable $exception) {
    fwrite(STDERR, sprintf("Invalid log level '%s'\n", $logLevel));
    fwrite(STDERR, ExceptionFormatter::format($exception) . PHP_EOL);
    exit(2);
}

$generator = __DIR__ . '/gen-commands';
$runner = __DIR__ . '/run-commands';
$comparator = __DIR__ . '/compare-outputs';

$oldVersion = getRedisVersion($phpOld);
$newVersion = getRedisVersion($phpNew);

if ($oldVersion !== '' && $newVersion !== '' && strtolower($oldVersion) === strtolower($newVersion)) {
    logError('Identical phpredis versions detected', [
        'php_old' => $phpOld,
        'php_new' => $phpNew,
        'phpredis_version' => $oldVersion,
    ]);
    logSummary('identical-phpredis-version', 0, 0, microtime(true));
    exit(2);
}

foreach ([$generator, $runner, $comparator] as $binary) {
    if (!is_file($binary)) {
        logError('Missing binary', ['path' => $binary]);
        logSummary('missing-binary', 0, 0, microtime(true));
        exit(2);
    }
}

$workDir = buildWorkDir();
$cleanupWorkDir = true;
register_shutdown_function(static function () use ($workDir, &$cleanupWorkDir): void {
    if (!$cleanupWorkDir) {
        return;
    }

    $iterator = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator($workDir, FilesystemIterator::SKIP_DOTS),
        RecursiveIteratorIterator::CHILD_FIRST
    );

    foreach ($iterator as $file) {
        $filename = $file->getPathname();
        $file->isDir() ? @rmdir($filename) : @unlink($filename);
    }

    @rmdir($workDir);
});

logInfo(
    'Loop start',
    [
        'old' => $phpOld,
        'new' => $phpNew,
        'redis' => sprintf('%s->%s', $oldVersion ?: 'N/A', $newVersion ?: 'N/A'),
        'batch' => number_format($commandCount),
        'iters' => $iterations > 0 ? number_format($iterations) : 'âˆž',
        'keys' => number_format($keys),
        'members' => number_format($members),
        'cluster' => $clusterMode,
    ]
);

$iteration = 0;
$totalRuns = 0;
$totalCommands = 0;
$startTime = microtime(true);
$commandStats = [];
$lastAlwaysFalseWarningCommands = [];
$lastAlwaysFalseWarningIteration = -1;
$alwaysFalseWarningInterval = 25;
while (true) {
    if ($iterations > 0 && $iteration >= $iterations) {
        logSummary('completed', $totalRuns, $totalCommands, $startTime);
        exit(0);
    }

    $commandsFile = sprintf('%s/cmds.%d.jsonl', $workDir, $iteration);
    $outputOld = sprintf('%s/out_old.%d.jsonl', $workDir, $iteration);
    $outputNew = sprintf('%s/out_new.%d.jsonl', $workDir, $iteration);
    $iterationStart = microtime(true);

    logInfo('Iter start', [
        'iter' => number_format($iteration),
        'batch' => number_format($commandCount),
    ]);

    $generatorClusterOption = $clusterMode ? ' --cluster' : '';
    $cmd = sprintf(
        '%s %s --keys=%d --members=%d%s %d %s',
        escapeshellarg(PHP_BINARY),
        escapeshellarg($generator),
        $keys,
        $members,
        $generatorClusterOption,
        $commandCount,
        escapeshellarg($commandsFile)
    );
    $generatorResult = runCommand($cmd);
    if ($generatorResult['code'] !== 0) {
        logError(
            'gen-commands failed',
            array_merge(
                ['iter' => number_format($iteration)],
                commandFailureContext($cmd, $generatorResult)
            )
        );
        logSummary('gen-commands-failed', $totalRuns, $totalCommands, $startTime);
        exit(3);
    }

    $runnerClusterOption = $clusterMode ? ' --cluster' : '';
    $cmd = sprintf(
        '%s %s%s %s %s %s %d',
        escapeshellarg($phpOld),
        escapeshellarg($runner),
        $runnerClusterOption,
        escapeshellarg($commandsFile),
        escapeshellarg($outputOld),
        escapeshellarg($host),
        $port
    );
    $oldRunnerResult = runCommand($cmd);
    if ($oldRunnerResult['code'] !== 0) {
        logError(
            'run-commands failed',
            array_merge(
                [
                    'bin' => 'php-old',
                    'iter' => number_format($iteration),
                ],
                commandFailureContext($cmd, $oldRunnerResult)
            )
        );
        logSummary('run-commands-failed', $totalRuns, $totalCommands, $startTime);
        exit(4);
    }

    $cmd = sprintf(
        '%s %s%s %s %s %s %d',
        escapeshellarg($phpNew),
        escapeshellarg($runner),
        $runnerClusterOption,
        escapeshellarg($commandsFile),
        escapeshellarg($outputNew),
        escapeshellarg($host),
        $port
    );
    $newRunnerResult = runCommand($cmd);
    if ($newRunnerResult['code'] !== 0) {
        logError(
            'run-commands failed',
            array_merge(
                [
                    'bin' => 'php-new',
                    'iter' => number_format($iteration),
                ],
                commandFailureContext($cmd, $newRunnerResult)
            )
        );
        logSummary('run-commands-failed', $totalRuns, $totalCommands, $startTime);
        exit(5);
    }

    updateAlwaysFalseStats($outputOld, $commandStats, $iteration);
    updateAlwaysFalseStats($outputNew, $commandStats, $iteration);
    maybeWarnAlwaysFalseCommands(
        $commandStats,
        $lastAlwaysFalseWarningCommands,
        $lastAlwaysFalseWarningIteration,
        $iteration,
        $alwaysFalseWarningInterval
    );

    $cmd = sprintf(
        '%s %s %s %s',
        escapeshellarg(PHP_BINARY),
        escapeshellarg($comparator),
        escapeshellarg($outputOld),
        escapeshellarg($outputNew)
    );
    $compareResult = runCommand($cmd);
    $compareExitCode = $compareResult['code'];

    $totalRuns++;
    $totalCommands += $commandCount;

    if ($compareExitCode !== 0) {
        $cleanupWorkDir = false;
        logError('Diff found', [
            'iter' => number_format($iteration),
            'cmdfile' => $commandsFile,
            'old' => $outputOld,
            'new' => $outputNew,
            'dur' => formatDuration(microtime(true) - $iterationStart),
            'command' => $cmd,
        ]);
        logSummary('difference-detected', $totalRuns, $totalCommands, $startTime);
        exit(1);
    }

    logInfo('Iter ok', [
        'iter' => number_format($iteration),
        'dur' => formatDuration(microtime(true) - $iterationStart),
        'runs' => number_format($totalRuns),
        'cmds' => number_format($totalCommands),
    ]);

    cleanupIterationFiles($commandsFile, $outputOld, $outputNew);

    $iteration++;

    if ($sleepSeconds > 0) {
        sleep($sleepSeconds);
    }
}

function usage(): void
{
    fwrite(
        STDERR,
        <<<TXT
Usage: compare-loop --old=/path/php-old --new=/path/php-new
  [--iters=0] [--sleep=0] [--count=200] [--host=127.0.0.1] [--port=6379]
  [--loglevel=info] [--keys=128] [--members=1024] [--cluster]
TXT
    );
}

function getRedisVersion(string $phpBinary): string
{
    return trim((string) shell_exec(
        sprintf(
            '%s -r %s',
            escapeshellarg($phpBinary),
            escapeshellarg("echo phpversion('redis');")
        )
    ));
}

function buildWorkDir(): string
{
    $work = rtrim(sys_get_temp_dir(), DIRECTORY_SEPARATOR) .
        DIRECTORY_SEPARATOR .
        'phpredis_diff_' .
        getmypid();

    if (!mkdir($work, 0700) && !is_dir($work)) {
        fwrite(STDERR, "Failed to mkdir {$work}\n");
        exit(2);
    }

    return $work;
}

/**
 * @param string ...$files
 */
function cleanupIterationFiles(string ...$files): void
{
    foreach ($files as $file) {
        if ($file === '' || !is_file($file)) {
            continue;
        }

        @unlink($file);
    }
}

/**
 * @return array{code:int, output:list<string>, duration:float}
 */
function runCommand(string $command): array
{
    logDebug('Executing command', ['command' => $command]);

    $start = microtime(true);
    exec($command . ' 2>&1', $output, $code);
    $duration = microtime(true) - $start;

    logDebug('Command completed', [
        'command' => $command,
        'exit_code' => (int) $code,
        'duration' => formatDuration($duration),
    ]);

    return [
        'code' => (int) $code,
        'output' => $output,
        'duration' => $duration,
    ];
}

function logInfo(string $message, array $context = []): void
{
    logger()->info($message, $context);
}

function logDebug(string $message, array $context = []): void
{
    logger()->debug($message, $context);
}

function logWarning(string $message, array $context = []): void
{
    logger()->warning($message, $context);
}

function logError(string $message, array $context = []): void
{
    logger()->error($message, $context);
}

function logSummary(string $status, int $totalRuns, int $totalCommands, float $startTime): void
{
    logInfo('Summary', [
        'status' => $status,
        'runs' => number_format($totalRuns),
        'cmds' => number_format($totalCommands),
        'time' => formatDuration(microtime(true) - $startTime),
    ]);
}

/**
 * @param array{code:int, output:list<string>, duration:float} $result
 * @return array<string,mixed>
 */
function commandFailureContext(string $command, array $result): array
{
    $context = [
        'command' => $command,
        'exit_code' => $result['code'],
        'duration' => formatDuration($result['duration']),
    ];

    $output = formatCommandOutput($result['output']);
    if ($output !== '') {
        $context['output'] = $output;
    }

    return $context;
}

/**
 * @param list<string> $lines
 */
function formatCommandOutput(array $lines): string
{
    if ($lines === []) {
        return '';
    }

    $normalized = array_values(
        array_filter(
            array_map(static fn(string $line): string => trim($line), $lines),
            static fn(string $line): bool => $line !== ''
        )
    );

    if ($normalized === []) {
        $normalized = $lines;
    }

    $maxLines = 5;
    $selected = array_slice($normalized, 0, $maxLines);
    $output = implode(' | ', $selected);

    $remaining = count($normalized) - count($selected);
    if ($remaining > 0) {
        $output .= sprintf(' (and %d more lines)', $remaining);
    }

    return $output;
}

function normalizeLogLevel(string $level): string
{
    $normalized = strtolower($level);

    $aliases = [
        'warn' => 'warning',
        'err' => 'error',
        'crit' => 'critical',
        'fatal' => 'critical',
        'panic' => 'alert',
        'trace' => 'debug',
    ];

    return $aliases[$normalized] ?? $normalized;
}

function formatDuration(float $seconds): string
{
    if ($seconds < 0) {
        $seconds = 0.0;
    }

    if ($seconds < 1) {
        return sprintf('%dms', (int) round($seconds * 1000));
    }

    $parts = [];

    $hours = (int) floor($seconds / 3600);
    if ($hours > 0) {
        $parts[] = $hours . 'h';
        $seconds -= $hours * 3600;
    }

    $minutes = (int) floor($seconds / 60);
    if ($minutes > 0) {
        $parts[] = $minutes . 'm';
        $seconds -= $minutes * 60;
    }

    $seconds = round($seconds, 2);
    $parts[] = sprintf('%0.2fs', $seconds);

    return implode('', $parts);
}

/**
 * @param array<string, array{only_false:bool,count:int,false_count:int,first_iter:int,last_iter:int}> $stats
 */
function updateAlwaysFalseStats(string $path, array &$stats, int $iteration): void
{
    if (!is_readable($path)) {
        return;
    }

    $handle = @fopen($path, 'rb');
    if ($handle === false) {
        logDebug('Failed to open output file for tracking', ['path' => $path]);
        return;
    }

    while (($line = fgets($handle)) !== false) {
        $line = trim($line);
        if ($line === '') {
            continue;
        }

        $record = json_decode($line, true);
        if (!is_array($record) || (($record['type'] ?? '') === 'meta')) {
            continue;
        }

        $command = $record['cmd'] ?? null;
        if (!is_string($command) || $command === '') {
            continue;
        }

        if (!array_key_exists($command, $stats)) {
            $stats[$command] = [
                'only_false' => true,
                'count' => 0,
                'false_count' => 0,
                'first_iter' => $iteration,
                'last_iter' => $iteration,
            ];
        } else {
            $stats[$command]['last_iter'] = $iteration;
        }

        $stats[$command]['count']++;

        if (($record['error'] ?? null) !== null) {
            $stats[$command]['only_false'] = false;
            continue;
        }

        $result = $record['result'] ?? null;
        if (
            is_array($result) &&
            ($result['_type'] ?? null) === 'bool' &&
            array_key_exists('v', $result) &&
            $result['v'] === false
        ) {
            $stats[$command]['false_count']++;
            continue;
        }

        $stats[$command]['only_false'] = false;
    }

    fclose($handle);
}

/**
 * @param array<string, array{only_false:bool,count:int,false_count:int,first_iter:int,last_iter:int}> $stats
 * @param list<string> $lastWarnedCommands
 */
function maybeWarnAlwaysFalseCommands(
    array $stats,
    array &$lastWarnedCommands,
    int &$lastWarningIteration,
    int $iteration,
    int $interval
): void {
    $candidates = [];
    foreach ($stats as $command => $info) {
        if ($info['only_false'] && $info['false_count'] > 0) {
            $candidates[$command] = $info;
        }
    }

    if ($candidates === []) {
        $lastWarnedCommands = [];
        $lastWarningIteration = -1;
        return;
    }

    $names = array_keys($candidates);
    sort($names);

    $shouldLog = $names !== $lastWarnedCommands;
    if (!$shouldLog && $interval > 0 && $lastWarningIteration >= 0) {
        $shouldLog = ($iteration - $lastWarningIteration) >= $interval;
    } elseif (!$shouldLog && $lastWarningIteration < 0) {
        $shouldLog = true;
    }

    if (!$shouldLog) {
        return;
    }

    $examples = [];
    foreach ($names as $name) {
        $examples[] = sprintf(
            '%s(count=%d,false=%d,first_iter=%d,last_iter=%d)',
            $name,
            $candidates[$name]['count'],
            $candidates[$name]['false_count'],
            $candidates[$name]['first_iter'],
            $candidates[$name]['last_iter']
        );

        if (count($examples) >= 5) {
            break;
        }
    }

    $context = [
        'total' => count($names),
        'examples' => $examples,
    ];

    if (count($names) > count($examples)) {
        $context['more'] = count($names) - count($examples);
    }

    logWarning('Commands only returning false', $context);

    $lastWarnedCommands = $names;
    $lastWarningIteration = $iteration;
}

function logger(): LoggerInterface
{
    /** @var LoggerInterface $logger */
    global $logger;

    return $logger;
}
